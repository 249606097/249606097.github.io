<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习基础-2</title>
      <link href="/2020/10/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-2/"/>
      <url>/2020/10/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-2/</url>
      
        <content type="html"><![CDATA[<p>这是软件工程课程第二次学习笔记。</p><a id="more"></a><h2 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h2><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><h4 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h4><p>对于给定的矩阵 $A$，假设其特征值为 $\lambda$，特征向量为 $\boldsymbol x$，则它们之间的关系如下：</p><script type="math/tex; mode=display">A \boldsymbol x = \lambda \boldsymbol x</script><p>从线性变换的角度，矩阵相乘对原始向量同时施加方向变化和尺度变化，而对于有些特殊向量，矩阵的作用只有尺度变化而没有方向变化，这类特殊的向量就是特征向量，尺度变化系数就是特征值。</p><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>矩阵 $A$ 的列秩是 $A$ 的线性独立的纵列的极大数，通常表示为 $r(A)$ 或 $rank(A)$。</p><ul><li><p>线性方程组的角度：度量矩阵行列之间的相关性。</p><p>如果矩阵的各行或各列是线性无关的，矩阵就是满秩的，也就是秩等于行数。</p></li><li><p>数据分布的角度：表示数据需要的最小的基的数量。</p><p>数据分布模式越容易被捕获，即需要的基越少，秩就越小。</p><p>数据冗余度越大，需要的基就越少，秩就越小。</p><p>若矩阵表示的是结构化信息，如图像、用户-物品等，各行之间存在一定相关性，一般是低秩的。</p></li></ul><h4 id="矩阵的奇异值"><a href="#矩阵的奇异值" class="headerlink" title="矩阵的奇异值"></a>矩阵的奇异值</h4><p>矩阵的奇异值分解 (singular value decomposition, SVD) 是一个能是英语任意矩阵的一种分解方法。</p><p>对于一个 $m*n$ 的矩阵 $A$，可分解为</p><script type="math/tex; mode=display">A = U \Sigma V^T</script><p>其中 $U$ 和 $V$ 都是正交矩阵，即有 $UU^T = I$ 和 $VV^T = I$，左奇异矩阵 $U$ 是 $m<em>m$ 的矩阵，右奇异矩阵 $V$ 是 $n</em>n$ 的矩阵， $\Sigma$ 是 $m*n$ 的矩阵，矩阵 $\Sigma$ 除对角线元素以外均为 0，对角线上的元素被称为奇异值。</p><p>矩阵 $\Sigma$ 形如</p><script type="math/tex; mode=display">\Sigma = \left [\begin{matrix}\sigma_1 & 0 & 0 & \cdots & 0 \\0 & \sigma_2 & 0 & \cdots & 0 \\0 & 0 & \sigma_3 & \cdots & 0 \\\vdots & \vdots & \vdots & \ddots & 0 \\0 & 0 & 0 & \vdots & 0\end{matrix}\right ]_{m \times n}</script><p>较大的奇异值包含了矩阵的主要信息，只保留前 $k$ 个（一般 $k$ 取 $\frac{n}{10}$ 就可以保留足够的信息）较大奇异值及其对应的特征向量可实现数据从 $m<em>n$ 降维到 $(m </em> k + k <em> r + k </em> d)$。</p><h4 id="矩阵的低秩近似"><a href="#矩阵的低秩近似" class="headerlink" title="矩阵的低秩近似"></a>矩阵的低秩近似</h4><script type="math/tex; mode=display">A_{m \times n} = U_{m \times n} \Sigma_{n \times n} V_{n \times n}^T \ \ \ \ \ rank(A) = r \ \ \ \ \ \ \\\hat{A}_{m \times k} = U_{m \times k} \Sigma_{k \times k} V_{k \times n}^T \ \ \ \ \ \ \ rank(\hat{A}) = k < r</script><p>低秩近似的意义：保留决定数据分布的最重要的模式/方向（丢弃的可能是噪声或其他不关键的信息）</p><h3 id="深度学习基础-1"><a href="#深度学习基础-1" class="headerlink" title="深度学习基础"></a>深度学习基础</h3><h4 id="机器学习三要素"><a href="#机器学习三要素" class="headerlink" title="机器学习三要素"></a>机器学习三要素</h4><ul><li><p>模型</p><p>对要学习问题映射的假设（问题建模，确定假设空间）</p></li><li><p>策略</p><p>从假设空间中学习/选择最优模型的准则（确定目标函数）</p></li><li><p>算法</p><p>根据目标函数求解最优模型的具体计算方法（求解模型参数）</p></li></ul><h4 id="策略设计：训练误差-泛化误差"><a href="#策略设计：训练误差-泛化误差" class="headerlink" title="策略设计：训练误差 -> 泛化误差"></a>策略设计：训练误差 -> 泛化误差</h4><p>“最合适”的模型：机器学习从有限的观测数据中学习出规律，并将总结的规律推广到未观测的样本上（追求泛化性能）</p><ul><li><p>泛化误差（期望风险）</p><script type="math/tex; mode=display">R(f) = \mathbb{E}_{(x,y) \sim p(x,y)}L(f(x),y)</script><p>其中 $L( \cdot )$ 为损失函数，$(x,y) \sim p(x,y)$ 符合真实数据分布</p></li><li><p>训练误差（经验风险）</p><script type="math/tex; mode=display">R_{训练}(f) = \frac{1}{N} \sum_{i=1}^{N} L(f(x^{(i)}),y^{(i)})</script><p>模型在训练样本上的平均损失</p></li><li><p>泛化错误</p><script type="math/tex; mode=display">G = R(f) - R_{训练}(f)</script></li></ul><p>策略目标：训练误差小 \&amp; 泛化错误低</p><p>机器学习的目的是获得小的泛化误差</p><ul><li>训练误差要小</li><li>训练误差与泛化误差足够接近 (generalization gap 要小)</li></ul><p>PAC 给出了实际训练学习器的目标：从合理数据的训练数据中通过合理计算量学习到了可靠的知识</p><ul><li>合理数据训练数据：数据集大小</li><li>合理计算量：学习训练的时间</li><li>可靠的知识：概率的置信度，近似的误差上界</li></ul><h4 id="策略设计：无免费午餐定理"><a href="#策略设计：无免费午餐定理" class="headerlink" title="策略设计：无免费午餐定理"></a>策略设计：无免费午餐定理</h4><blockquote><p>当考虑在所有问题上的平均性能时，任意两个模型都是相同的。</p></blockquote><p>脱离具体问题，谈“什么学习算法更好”毫无意义。（周志华）</p><p>没有任何一个模型可以在所有的学习任务理表现最好。</p><p><img src="https://i.loli.net/2020/10/24/PrShXBFlo1DqHCm.png" alt=""></p><h4 id="策略设计：奥卡姆剃刀原理"><a href="#策略设计：奥卡姆剃刀原理" class="headerlink" title="策略设计：奥卡姆剃刀原理"></a>策略设计：奥卡姆剃刀原理</h4><blockquote><p>如无必要，勿增实体。</p></blockquote><p>如果多种模型能够同等程度地符合一个问题的观测结果，应该选择其中使用假设最少的。（最简单的模型）</p><ul><li><p>惩罚大模型复杂度</p><p>最小结构风险：</p><script type="math/tex; mode=display">R_{结构}(f) = \frac{1}{N}\sum_{i=1}^{N}L(f(x^{(i)}),y^{(i)}) + \lambda J(f)</script><p>其中 $\lambda J(f)$ 表示模型复杂度，如参数向量的 1 范数。</p><p>最大后验概率：</p><script type="math/tex; mode=display">P(h|D) \propto P(D|h) \cdot P(h)</script><p>其中 $P(D|h)$ 是似然，$P(h)$ 是模型的先验，复杂模型是小概率事件。</p></li><li><p>欠拟合 vs 过拟合</p><p>欠拟合：训练集的一般性质尚未被学习器学好。（训练误差大）</p><p>提高模型复杂度</p><ul><li>决策树：拓展分支</li><li>神经网络：增加节点个数，增加训练轮数</li></ul></li></ul><p>  过拟合：学习器把训练集特点当作样本的一般特点。（训练误差小，测试误差大）</p><p>  降低模型复杂度</p><ul><li>优化目标加正则项</li><li>决策树：剪枝</li><li>神经网络：early stop, dropout</li><li>数据增广（训练集越大，越不容易过拟合）</li></ul><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>BP 神经网络和损失函数</p><p>如果设定 $S(x)=\frac{1}{1+exp(-x)}$，那么损失函数</p><script type="math/tex; mode=display">L = \frac{1}{2} \sum_{k=1}^{N}D(f(x_k),h(x_k)) =  \frac{1}{2}\sum_{k=1}^{N}\sum_{i=1}^{c} (f_i(x_k)-x_{k_i}^{(\mathfrak{H})})^2=\sum_{k=1}^{N}E_k</script><p>令 $E_k = \sum_{i=1}^{c}(f_i(x_k)-x_{k_i}^{(\mathfrak{H})})^2$ 为每个样本的平方损失代价，$(x)_i^{(\mathfrak{H})}=S\left( (W_i^{(\mathfrak{H}-1)})^T(x)^{(\mathfrak{H}-1)} \right)$。</p><p>待优化参数：权重 $w_{ij}^{(t)}$</p><p>优化算法：梯度下降，需要计算代价函数 L 和梯度 $\frac{\partial L}{\partial w_{ij}^{(t)}} = \sum_{k=1}^{N} \frac{\partial E_k}{\partial w_{ij}^{(t)}}$，更新公式 $w_{ij}^{(t)} \leftarrow w_{ij}^{(t)} - \eta \frac{\partial E_k}{\partial w_{ij}^{(t)}}$。</p><ul><li><p>平方损失</p><p>平方损失是计算在最后一层（输出层）的，使用 Sigmoid 函数</p></li></ul><script type="math/tex; mode=display">\frac{\partial L}{\partial w_i} = 2(a - y) \cdot a(1-a) \cdot x_i</script><ul><li><p>交叉熵（对数损失函数）</p><script type="math/tex; mode=display">L(a,y)=-y\log a - (1-y)\log (1-a)</script><script type="math/tex; mode=display">L(y,f(x,\theta))=-\sum_{i=1}^{C}y_i\log f_i(x,\theta)</script><p>对于参数 $w$ 是凸的。平方损失假设高斯分布，而分类问题是二项/多项分布，对数损失与二项/多项分布下的最大似然等价。</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w} = (a-y)\sigma'(z)x = a\sigma'(z) \\\frac{\partial L}{\partial w_j} = \frac{1}{n}\sum_{x}(\sigma(z)-y)</script><p>输出层的梯度大小不受激活函数的导数影响，损失函数下降速度快。</p></li></ul><h4 id="频率学派-vs-贝叶斯学派"><a href="#频率学派-vs-贝叶斯学派" class="headerlink" title="频率学派 vs 贝叶斯学派"></a>频率学派 vs 贝叶斯学派</h4><p>概率论代表了一种看待世界的方式，对随机事件发生的可能性进行管泛化数学描述，对可能性的不同解读促生了概率轮的两个学派，频率学派和贝叶斯学派。</p><p>频率学派</p><ul><li><p>关注可独立重复的随机试验中单个事件发生的频率</p></li><li><p>可能性：事件发生频率的极限值，也就是说重复试验次数趋近于无穷大时，事件发生的频率会收敛到真实的概率</p></li></ul><p>假设概率是客观存在且固定的，模型参数是唯一的，需要从有限的观测数据中估计参数。</p><p>频率学派对应统计机器学习（线性回归、决策树、支持向量机）</p><p>贝叶斯学派</p><ul><li>关注随机事件的“可信程度”，如天气预报明天下雨的概率（无法重复）</li><li>可行性 = 假设 + 数据：数据的作用是对初始假设做出修正，使观察者对概率的主观认识（先验）更接近客观实际（观测）</li></ul><p>模型参数本身是随机变量，需要估计参数的整个概率分布。</p><p>贝叶斯学派对应概率图模型（隐马尔可夫链、条件随机场、主题模型）</p><div class="table-container"><table><thead><tr><th></th><th>频率学派</th><th>贝叶斯学派</th></tr></thead><tbody><tr><td>利用的信息</td><td>观测数据 $X$</td><td>观测数据 $X$ + 先验 $p(\theta)$</td></tr><tr><td>参数估计</td><td>确定参数值 $\hat{\theta}$</td><td>参数后验分布 $p(\theta \mid X)$</td></tr></tbody></table></div><p>机器学习问题中样本数据有限，核心任务之一就是对模型的参数进行估计。</p><p>极大似然估计</p><p>使训练数据出现的概率最大化，依次确定模型的参数</p><script type="math/tex; mode=display">\hat{\theta} = argmax_{\theta}P(X|\theta)</script><p>最大后验估计（贝叶斯估计）</p><p>根据训练数据和已知先验，估计参数分布；选择参数分布概率最大的值作为估计值</p><script type="math/tex; mode=display">\hat{\theta} = argmax_{\theta}P(\theta |X) = argmax_{\theta}P(X|\theta)P(\theta)</script><h4 id="统计机器学习"><a href="#统计机器学习" class="headerlink" title="统计机器学习"></a>统计机器学习</h4><p>统计机器学习是寻找相关性</p><p>Yule-Simpson 悖论表明相关性不可靠，相关关系可能由于 context 等混杂因素而改变。</p><blockquote><p>当人们尝试探究两种变量（比如新生录取率与性别）是否具有相关性的时候，会分别对之进行分组研究。然而，在分组比较中都占优势的一方，在总评中有时反而是失势的一方。</p></blockquote><h4 id="相关性和因果性"><a href="#相关性和因果性" class="headerlink" title="相关性和因果性"></a>相关性和因果性</h4><p>相关性：Y 的发生往往伴随着 X。</p><p><img src="https://i.loli.net/2020/10/24/VSAuhxPpisaE1nt.png" alt=""></p><p>因果性：排除其他因素后，Y 仅由 X 影响。</p><p><img src="https://i.loli.net/2020/10/24/4WOX1gJTDdR7GEf.png" alt=""></p><p>例如，打伞、地上湿、下雨之间的关系。</p><p><img src="https://i.loli.net/2020/10/24/y4orIwc5X3H9gb2.png" alt=""></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>卷积神经网络的基本应用：分类、检索、检测、分割。</p><p>深度学习的三步</p><ol><li><p>搭建神经网络的结构</p></li><li><p>找到一个合适的损失函数</p><p>交叉熵损失 (cross entropy loss)，均方误差 (MSE)，等等。</p></li><li><p>找到一个合适的优化函数，更新参数</p><p>反向传播 (BP)，随机梯度下降 (SGD)，等等。</p></li></ol><h3 id="常用的损失函数"><a href="#常用的损失函数" class="headerlink" title="常用的损失函数"></a>常用的损失函数</h3><ul><li><p>常用分类损失</p><p>交叉熵损失: $Loss = -\sum y_i\ln y_i^p$</p><p>hinge loss: $L(y,f(x))=max(0,1-yf(x))$</p></li><li><p>常用回归损失</p><p>均方误差: $MSE=\sum_{i=1}^{n}(y_i-y_i^p)^2$</p><p>平均绝对值误差（L1 损失）: $MAE=\sum_{i=1}^{n}|y_i-y_i^p|$</p></li></ul><h3 id="基本组成结构"><a href="#基本组成结构" class="headerlink" title="基本组成结构"></a>基本组成结构</h3><p>卷积 Convolutional Layer 是对两个实变函数（以实数为自变量的函数）的一种数学操作。</p><h4 id="一维卷积"><a href="#一维卷积" class="headerlink" title="一维卷积"></a>一维卷积</h4><p>一维卷积经常用在信号处理中，用于计算信号的延迟累积。</p><p>假设一个信号发生器在时刻 $t$ 发出一个信号 $x_t$，其信息的衰减率为 $f_k$，即在 $k-1$ 个时间步长后，信息衰减为原来的 $f_k$ 倍。设 $f_1=1,f_2=\frac{1}{2},f_3=\frac{1}{4}$，在时刻 $t$ 收到的信号 $y_t$ 为当前时刻产生的信息和以前时刻延迟信息的叠加</p><script type="math/tex; mode=display">\begin{aligned}y_t &= 1 \times x_t + \frac{1}{2} \times x_{t-1} + \frac{1}{4} \times x_{t-2} \\    &= f_1 \times x_t + f_2 \times x_{t-1} + f_3 \times x_{t-2} \\    &= \sum_{k=1}^{3}f_k \cdot x_{t-k+1}\end{aligned}</script><p>此处的 $f = [f_1, f_2, f_3]$ 被称为滤波器 (filter) 或卷积核 (convolutional kernel)。</p><p>设滤波器 $f$ 长度为 $m$，它和一个信号序列 $x=[x_1,x_2,x_3,\dots]$ 的卷积记为</p><script type="math/tex; mode=display">y_t = \sum_{k=1}^{m} f_k \cdot x_{t-k+1}</script><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>input: 输入</li><li>filter/kernel: 过滤器/ 卷积核</li><li>weights: 权重</li><li>receptive field: 感受野</li><li>activation map/feature map: 特征图</li><li>stride: 步长</li><li>padding: 填补</li><li>depth/channel: 深度</li><li>output: 输出</li></ul><p>未加 padding 时输出的特征图大小：$\frac{N-F}{stride} + 1$，加 padding 时输出的特征图的大小：$\frac{N + padding \times 2 - F}{stride} + 1$。</p><p>池化 Pooling Layer</p><ul><li><p>Pooling 保留主要特征的同时减少参数和计算量，防止过拟合，提高模型泛化能力。它一般处于卷积层与卷积层之间，全联接层与全连接层之间</p></li><li><p>Pooling 的类型：Max pooling 最大值池化（分类问题常用），Average pooling 平均池化</p></li></ul><p>全连接 Fully Connected Layer, FC Layer</p><ul><li>全联接层的两层之间所有神经元都有权重链接</li><li>通常全连接层在卷积神经网络尾部</li><li>全连接层参数量通常最大</li></ul><h4 id="卷积神经网络经典结构"><a href="#卷积神经网络经典结构" class="headerlink" title="卷积神经网络经典结构"></a>卷积神经网络经典结构</h4><p>经典结构有AlexNet, ZFNet, VGG, GoogleNet, ResNet 等。</p><p><img src="https://i.loli.net/2020/10/24/ZVsfNMm7Fhxb1AG.png" alt=""></p><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p>AlexNet 之所以能成功，深度学习之所以能重回历史舞台，原因在于：</p><ul><li>大数据训练：百万级 ImageNet 图像数据</li><li>非线性激活函数：ReLU</li><li>放回过拟合：Dropout, Data Augmentation</li><li>其他：双 GPU 实现</li></ul><p>使用 ReLU 函数对比使用 Sigmoid 函数的优点</p><ul><li>解决了梯度消失问题（在正区间）</li><li>计算速度特别快，只需要判断输入是否大于 0</li><li>收敛速度快于 Sigmoid 函数</li></ul><p>应用 Dropout（随机失活），训练时随机关闭部分神经元，测试时整合所有神经元。</p><p>数据增强 (data augmentation)</p><ul><li><p>平移、翻转、对称</p><ul><li>随机 crop。训练时，对于 256*256 的图片进行随机 crop 到 224*224。</li><li>水平翻转，相当于将样本倍增。</li></ul></li><li><p>改变 RGB 通道强度</p><p>对 RGB 空间做一个高斯扰动。</p><p>每个 RGB 图片的像素 $I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]^T$</p><p>$I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]^T + [p_1,p_2,p_3][\alpha_1\lambda_1,\alpha_2\lambda_2,\alpha_3\lambda_3]^T$</p></li></ul><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p>VGG 是一个更深的网络。</p><h4 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h4><p>网络总体结构：</p><ul><li>网络包含 22 个带参数的层（如果考虑 pooling 层就有 27 层），独立成块的层总共约有 100 个</li><li>参数量大概是 AlexNet 的 1/12</li><li>没有 FC 层</li></ul><p>Naive Inception 初衷：多卷积核增加特征多样性</p><p>Inception V3 进一步对 v2 的参数进行降低。（使用两个 3*3 的卷积核代替一个 5*5 的卷积核），好处是降低了参数量，增加非线性激活函数，使网络产生更多独立特 (disentagled feature)，表征能力更强，训练更快。</p><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>残差学习网络 (deep residual learning network)，深度有 152 层。</p><p>残差的思想：去掉相同的主体部分，从而突出微小的变化，可以被用来训练非常深的网络。</p><p>对于一个神经网络训练的目的是拟合 $H(x)$，但当网络层数增多时，直接拟合 $H(x)$ 十分困难，所以 ResNet 不直接拟合 $H(x)$，而是拟合 $H(x) - x$，这就是残差 (residual)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础</title>
      <link href="/2020/10/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/10/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>这是初步学习机器学习的笔记。</p><a id="more"></a><h4 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h4><p><img src="https://i.loli.net/2020/10/15/C4DhpAgkfPIYzUJ.png" style="zoom:70%;" /></p><ul><li>每个神经元都是一个<strong>多输入单输出</strong>的信息处理单元</li><li>神经元具有<strong>空间整合</strong>和<strong>时间整合</strong>的特性</li><li>神经元输入分<strong>兴奋性输入</strong>和<strong>抑制性输入</strong>两种输入类型</li><li>神经元具有<strong>阀值</strong>特性</li></ul><h4 id="M-P-神经元"><a href="#M-P-神经元" class="headerlink" title="M-P 神经元"></a>M-P 神经元</h4><p><img src="https://i.loli.net/2020/10/15/8ByHvhNScID5VWG.png" alt=""></p><p>其中 $x_i$ 为来自第 $i$ 个神经元的输入，$w_i$ 为第 $i$ 个神经元的连接权重，$\theta$ 为阀值。</p><p>输出 $y$</p><script type="math/tex; mode=display">y = f \left(\sum_{i=1}^{n} w_ix_i - \theta \right) = W^Tx = \left[\begin{matrix}-\theta &w_1 &w_2 &\cdots &w_n\end{matrix}\right]\left[\begin{matrix}1 \\x_1 \\x_2 \\\vdots \\x_n\end{matrix}\right]</script><ul><li><p>多输入信号进行累加 $\sum_i{x_i}$</p></li><li><p>权值 $w_i$ 正负模拟兴奋/抑制，大小模拟强度</p></li><li>输入和超过阀值 $\theta$，神经元被激活 (fire)</li></ul><p>输出 $y$ 的公式中均在激活函数 $f(\cdot)$，激活函数的作用是加入非线性因素，如果没有激活函数，那么多层神经网络最终产生的结果相当于矩阵的连乘，而矩阵的连乘的结果依然是一个矩阵，即 $x^TW_1 \cdots W_n = x^T \prod_{k=1}^n W_k = x^TW$，多层神经网络相当于一层，并且矩阵的相乘是线性变化，从而导致没有激活函数的神经网络只能拟合线性函数。</p><h4 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h4><h4 id="S-性函数-sigmoid"><a href="#S-性函数-sigmoid" class="headerlink" title="S 性函数(sigmoid)"></a>S 性函数(sigmoid)</h4><script type="math/tex; mode=display">\sigma(x) = \frac{1}{1+e^{-x}} \\\sigma(x)' = \sigma(x)(1-\sigma(x))</script><p><img src="https://i.loli.net/2020/10/15/aMOPDmlzJ39cq1I.png" style="zoom:70%;" /></p><h4 id="双极-S-性函数-tanh"><a href="#双极-S-性函数-tanh" class="headerlink" title="双极 S 性函数(tanh)"></a>双极 S 性函数(tanh)</h4><script type="math/tex; mode=display">tanh(x) = 2sigmoid(2x) - 1 = \frac{e^x - e^{-x}}{e^x + e^{-x}} \\tanh(x)' = 1- tanh^2(x)</script><p><img src="https://i.loli.net/2020/10/15/Ry5eH7LqAvVk2Pz.png" style="zoom:70%;" /></p><h4 id="ReLU-函数-修正线性单元-Rectified-Linear-Unit"><a href="#ReLU-函数-修正线性单元-Rectified-Linear-Unit" class="headerlink" title="ReLU 函数(修正线性单元 Rectified Linear Unit)"></a>ReLU 函数(修正线性单元 Rectified Linear Unit)</h4><script type="math/tex; mode=display">relu(x) = max(0, x)</script><p><img src="https://i.loli.net/2020/10/15/WkzyqZSPmNi7McV.png" style="zoom:70%;" /></p><h4 id="单层感知器"><a href="#单层感知器" class="headerlink" title="单层感知器"></a>单层感知器</h4><p>M-P 神经元的权重是预先设置的，无法进行学习。</p><p>单层感知器是首个可以学的的人工神经网络。</p><p>单层感知器的结构与 M-P 神经网络是基本一致的，不同的是单层感知器的权重矩阵 $W$ 是可以自动学习的。</p><p><img src="https://i.loli.net/2020/10/18/zUjNMF1TSRVE3Du.png" alt=""></p><p>单层感知器可以用在一些简单的方面，如实现一个逻辑非，这里我们使用 sigmoid 函数作为激活函数。</p><p><img src="https://i.loli.net/2020/10/18/9JFyr2DOUHRcwu7.png" alt=""></p><script type="math/tex; mode=display">h_{\theta}(x) = \sigma(10 - 20x_1)</script><div class="table-container"><table><thead><tr><th style="text-align:center">$x$</th><th style="text-align:center">$NOT \space x$</th><th style="text-align:center">$10-20x$</th><th style="text-align:center">$h_{\theta}(x)$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">0.99995 ≈ 1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">-10</td><td style="text-align:center">0.00005 ≈ 0</td></tr></tbody></table></div><p>对于逻辑与、逻辑或等线性的功能，单层感知器能够很好地实现，输入 $x$ 作为样本，输出 $y$ 作为标签，单层感知器的作用就是在 01 空间中做一个线性超平面将标签分类。</p><p><img src="https://i.loli.net/2020/10/18/gYMDA2zPjKrmJ51.png" alt=""></p><p>但对于逻辑异或功能，无法通过做一个线性超平面将标签分类，所以单层感知器无法完成非线性问题，这时候就需要将多层感知器扩展到多层感知器，多层感知器的叠加解决非线性问题。</p><h4 id="万有逼近定理"><a href="#万有逼近定理" class="headerlink" title="万有逼近定理"></a>万有逼近定理</h4><blockquote><p>如果一个隐层包含句够多的神经元，三层前馈神经网络（输入 - 隐层 - 输出）能以任意精度逼近任意预定的连续函数。</p></blockquote><p>对于一个三层前馈神经网络，第一层的感知器实际上是做了一次空间变换，使得第二层感知器能够将做过空间变换的数据使用一个线性超平面划分。</p><blockquote><p>当隐层足够宽时，双隐层感知器（输入 - 隐层 1 - 隐层 2 - 输出）可以逼近任意非连续函数，可以解决任何复杂的分类问题。</p></blockquote><h4 id="神经网络每一层的作用"><a href="#神经网络每一层的作用" class="headerlink" title="神经网络每一层的作用"></a>神经网络每一层的作用</h4><p>每一层的数学公式 $\vec{y} = a(W \cdot \vec{x} + b)$，作用时完成输入空间到输出空间的空间变换，$W \cdot \vec{x}$ 实现升维/降维、放大/缩小、旋转，$+b$ 实现平移，$a(\cdot)$ 实现弯曲。</p><p>神经网络学习如何利用矩阵的线性变化加激活函数的非线性变换，降原输入空间投影到线性可分的空间去分类/回归。</p><ul><li>增加节点数：增加维度，即增加线性转换能力</li><li>增加层数：增加激活函数的次数，即增加肥线性转换次数</li></ul><h4 id="神经网络更宽-or-更深？"><a href="#神经网络更宽-or-更深？" class="headerlink" title="神经网络更宽 or 更深？"></a>神经网络更宽 or 更深？</h4><p>在神经元总数相当的情况下，增加网络深度可以比增加网络宽度带来更强的网络表示能力：产生更多的线性区域。</p><p>深度和宽度对函数的复杂度的贡献时不同的，深度的贡献时指数增长的，而宽度的贡献是线性的。</p><script type="math/tex; mode=display">FC = \prod_{l=1}^{d}(\alpha_l \cdot \theta_l)^{\beta_l}</script><p>其中 $\alpha$ 表示每层参数对函数复杂度的贡献，$\theta$ 表示参数数量，$\beta$ 表示深度对函数复杂度的贡献，$\alpha$ 和 $\beta$ 都是一个区间即相同的参数在不同数值下仍然有不同的复杂度。$d$ 表示最大深度，$l$ 表示第 $l$ 层。</p><p>但多层神经网络会出现梯度消失问题。</p><h4 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a>误差反向传播</h4><p>多层神经网络可以看成是一个复合的非线性多元函数 $F(\cdot): X \rightarrow Y$</p><script type="math/tex; mode=display">F(x) = f_n(_\cdots f_3(f_2(f_1(x)\times \theta_1 + b)\times \theta_2 + b)_\cdots)</script><p>给定训练数据 $\{x^i, y^i\}_{i=1:N}$，希望损失 $\sum_iloss(F(x^i), y^i)$ 尽可能小。</p><p>梯度是相对于导数提出的</p><ul><li><p>导数</p><p>函数值在某一点沿自变量正方向的变化率。</p></li><li><p>梯度</p><p>多元函数 $f(x,y)$ 在每个点可以有多个方向，每个方向都可以计算导数，称为方向导数。梯度是一个向量，方向是最大方向导数的方向，模是方向导数的最大值。</p></li></ul><p>无约束优化：梯度下降</p><p>参数沿负梯度方向更新可以使函数值下降</p><script type="math/tex; mode=display">\theta_j = \theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta)</script><p><img src="https://i.loli.net/2020/10/18/BJUym8rbefcaLgN.png" alt=""></p><p>复合函数的链式求导</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w_i} = \frac{\partial L}{\partial \alpha} \cdot \frac{\partial \alpha}{\partial z} \cdot \frac{\partial z}{\partial w_i} \triangleq dw_i</script><script type="math/tex; mode=display">L = \sum_{k=1}^{c}(a_k-y_k)^2 \space \space \space \space \space \space \space \space \space \space \sigma (z) = \frac{1}{1+e^{-z}}</script><p>那么</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w_i} = 2(a-y) \cdot a(1-a) \cdot x_i</script><p>这里引入一个定义残差，残差是损失函数在某个节点的偏导。</p><p>深层神经网络的问题：梯度消失</p><p>前向传播</p><p><img src="https://i.loli.net/2020/10/18/s5aXEGiJHV6734W.png" alt=""></p><p>反向传播（误差通过梯度传播）</p><script type="math/tex; mode=display">\frac{\partial C}{\partial b_1} = \sigma '(b_1)w_2 \sigma '(b_2)w_3 \sigma '(b_3)w_4 \sigma '(b_4) \frac{\partial C}{\partial b_4}</script><p>对于 sigmoid 激活函数，它的导数的最大值仅为 $\frac{1}{4}$，并且它非常容易落入饱和区，在反向传播的过程中，最开始可能非常大，但是之后由于乘以了较小的激活函数导数值从而变得很小，使得误差反向传播仅影响了高层而对底层基本无影响。</p><h4 id="逐层预训练"><a href="#逐层预训练" class="headerlink" title="逐层预训练"></a>逐层预训练</h4><p>为了解决局部极小值和梯度消失问题，提出了逐层预训练 (layer-wise pre-training) 的方法，逐层预训练本质上是经过预训练获得一个比较好的初始值，之后再进行训练，使得能够获得不错的解。</p><p>逐层预训练有两种主要实现方式：自编码器和受限玻尔兹曼机。</p><p>自编码器 (autoencoder) 假设输入和输出相同 (target = input)，是一种尽可能复现输入信号的神经网络。将 input 输入一个 encoder 编码器，就会得到一个 code，加一个 decoder 解码器，输出信息。通过调整 encoder 和 decoder 的参数，使得重构误差最小。并且自编码器没有额外的监督信息（无标签数据），误差的来源是直接重构后信号与原输入相比得到的。</p><p><img src="https://i.loli.net/2020/10/18/bMlYevr4j1CD57Q.png" alt=""></p><p>自编码器一般是一个多层神经网络（最简单：三层），训练目的是使输出层与输入层误差最小，中间因层是代表输入的特征，可以最大程度上代表元输入信号。</p><script type="math/tex; mode=display">\begin{aligned}l &= \sum_{i=1}^{N} || x^{(i)} - g(f(x^{i})) ||^2 \\  &= \sum_{i=1}^{N} ||x^{(i)} - f \cdot g(x^{(i)}) ||^2\end{aligned}</script><p>编码器 (Encoder) $f: \mathbb{R^d} \rightarrow \mathbb{R^{d’}}$</p><p>解码器 (Decoder) $g: \mathbb{R^{d’}} \rightarrow \mathbb{R^d}$</p><p>自编码器最初是被提出用来降为的。</p><p>堆叠自编码器 (stacked auto encoder, SAE)，将多个自编码器得到的隐层串联，所有层预训练完成后，进行基于监督学习的全网络微调。</p><p><img src="https://i.loli.net/2020/10/18/LzQPC1eZcYVONtx.png" alt=""></p><p>受限玻尔兹曼机 (RBM)</p><p>RBM 是两层神经网络，包含可加层 v （输入层）和隐藏层 h，不同层之间值全连接（二分图），与感知器不同，RBM 没有显式的重构过程，输入 v，通过 $p(h|v)$ 得到隐层 h；输入 h，通过 $p(v|h)$ 得到 v，目的是让隐藏层得到的可见层 v’ 与原来的可见层 v 分布一致，从而使隐藏层作为可见层输入的特征。</p><p><img src="https://i.loli.net/2020/10/18/RIqv5oBkKPUn3ap.png" alt=""></p><p><img src="https://i.loli.net/2020/10/18/57LTYdjMHEaJmlD.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树 Tree</title>
      <link href="/2020/02/25/%E6%A0%91-Tree/"/>
      <url>/2020/02/25/%E6%A0%91-Tree/</url>
      
        <content type="html"><![CDATA[<p>树状是一种数据结构，它是由有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>树是由结点和边组成的且不存在着任何环的一种数据结构。一棵树包括一个根结点和有限个结点，所有结点构成一个多级分层结构。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p><img src="/images/img00018.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序 Sort</title>
      <link href="/2020/02/21/%E6%8E%92%E5%BA%8F-Sort/"/>
      <url>/2020/02/21/%E6%8E%92%E5%BA%8F-Sort/</url>
      
        <content type="html"><![CDATA[<p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</p><p>经典排序算法有</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>计数排序</li><li>桶排序</li></ul><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> tern <span class="keyword">in</span> range(len(li) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(tern):</span><br><span class="line">            <span class="keyword">if</span> li[i] &gt; li[i + <span class="number">1</span>]:</span><br><span class="line">                li[i], li[i + <span class="number">1</span>] = li[i + <span class="number">1</span>], li[i]</span><br></pre></td></tr></table></figure><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> tern <span class="keyword">in</span> range(len(li) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        max_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, tern + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[i] &gt; li[max_index]:</span><br><span class="line">                max_index = i</span><br><span class="line"></span><br><span class="line">        li[tern], li[max_index] = li[max_index], li[tern]</span><br></pre></td></tr></table></figure><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):</span><br><span class="line">        value = li[index]</span><br><span class="line">        position = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position &gt;= <span class="number">1</span> <span class="keyword">and</span> li[position - <span class="number">1</span>] &gt; value:</span><br><span class="line">            li[position] = li[position - <span class="number">1</span>]</span><br><span class="line">            position -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        li[position] = value</span><br></pre></td></tr></table></figure><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h2><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    gap = len(li) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(gap):</span><br><span class="line">            insertion_sort_with_gap(li, start, gap)</span><br><span class="line"></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort_with_gap</span><span class="params">(li, start, gap)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(start + gap, len(li), gap):</span><br><span class="line">        value = li[index]</span><br><span class="line">        position = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position &gt;= gap <span class="keyword">and</span> li[position - gap] &gt; value:</span><br><span class="line">            li[position] = li[position - gap]</span><br><span class="line">            position = position - gap</span><br><span class="line"></span><br><span class="line">        li[position] = value</span><br></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">    middle = len(li) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(li[:middle])</span><br><span class="line">    right = merge_sort(li[middle:])</span><br><span class="line"></span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>]:</span><br><span class="line">            merged.append(right.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    merged += left + right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h2><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    quick_sort_inner(li, <span class="number">0</span>, len(li) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort_inner</span><span class="params">(li, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        mid = partition(li, start, end)</span><br><span class="line"></span><br><span class="line">        quick_sort_inner(li, start, mid - <span class="number">1</span>)</span><br><span class="line">        quick_sort_inner(li, mid + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li, start, end)</span>:</span></span><br><span class="line">    base = li[start]</span><br><span class="line">    index = start + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> range(index, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> base &gt; li[one]:</span><br><span class="line">            li[index], li[one] = li[one], li[index]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    li[index - <span class="number">1</span>], li[start] = li[start], li[index - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找 Search</title>
      <link href="/2020/02/21/%E6%9F%A5%E6%89%BE-Search/"/>
      <url>/2020/02/21/%E6%9F%A5%E6%89%BE-Search/</url>
      
        <content type="html"><![CDATA[<p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p><a id="more"></a><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p><p>查找分为:</p><ol><li>静态查找和动态查找</li><li>有序查找和无序查找</li></ol><h2 id="顺序查找-Sequential-Search"><a href="#顺序查找-Sequential-Search" class="headerlink" title="顺序查找 Sequential Search"></a>顺序查找 Sequential Search</h2><p>如果数据项保存在如列表这样的集合中，我们称这些数据项具有线性或者顺序关系，通过如下标，我们就可以按照顺序来访问和查找数据项，这就称为“顺序查找”。顺序查找是按照原有顺序对列表进行遍历查询的基本查找算法。</p><p><img src="/images/img00016.png" alt=""></p><p>从列表头开始查找，按照下标的顺序逐个对比数据项，直到找到数据项，或者查找到列表末尾并未查找到。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>顺序查找</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_search</span><span class="params">(li, item)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(li)):</span><br><span class="line">        <span class="keyword">if</span> li[index] == item:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_list = [<span class="number">24</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">20</span>, <span class="number">44</span>, <span class="number">8</span>, <span class="number">43</span>, <span class="number">0</span>, <span class="number">81</span>, <span class="number">39</span>, <span class="number">92</span>, <span class="number">17</span>]</span><br><span class="line">    print(sequential_search(test_list, <span class="number">5</span>))  <span class="comment"># -1</span></span><br><span class="line">    print(sequential_search(test_list, <span class="number">0</span>))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><h2 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h2><p>二分查找，又称折半查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中数据项按关键字有序排列。</p><p><img src="/images/img00017.png" alt=""></p><p>折半查找的前提条件是数据项有序存储，能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><blockquote><p>二分查找</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(li, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(li) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> item &gt; li[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">44</span>, <span class="number">50</span>, <span class="number">68</span>, <span class="number">90</span>, <span class="number">92</span>, <span class="number">99</span>]</span><br><span class="line">    print(binary_search(test_list, <span class="number">9</span>)) <span class="comment"># -1</span></span><br><span class="line">    print(binary_search(test_list, <span class="number">8</span>)) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归 Recursion</title>
      <link href="/2020/02/18/%E9%80%92%E5%BD%92-Recursion/"/>
      <url>/2020/02/18/%E9%80%92%E5%BD%92-Recursion/</url>
      
        <content type="html"><![CDATA[<p>递归为我们提供了一种对复杂问题的优雅解决方案，精巧的递归算法常常十分简单，其精髓在于将问题分解为规模更小的相同问题，并持续分解直到问题的规模小到可以用非常简单的直接方式来解决。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>递归 Recursion，又称递回，在计算机科学中，是指在函数的定义中使用函数自身的方法。</p><p><img src="/images/img00009.png" alt=""></p><p>递归是一种解决问题的方法，其精髓在于将问题分解为规模更小的相同问题，并持续分解直到问题的规模小到可以用非常简单的直接方式来解决。递归的问题分解方式非常独特，其算法方面的明显特征就是: 在算法流程中调用自身，从而使得算法十分的简单。</p><p>递归对编写者来说，节省了大量的思考时间，但是对计算机处理来说，极不友好。递归消耗大量的栈资源，容易造成栈溢出，并且相比较与循环，通过开辟新的栈桢需要花费更多的时间，所以对于一个普通循化不宜编写，且递归深度不是特别大时，再考虑使用递归。</p><p><img src="/images/img00010.png" alt=""></p><p>Python 中默认的可递归深度是 1000，通过 <code>sys.getrecursionlimit()</code> 获取可递归深度，使用 <code>sys.setrecursionlimit(2000)</code> 修改可递归深度。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>递归算法的基本流程是</p><ul><li>递归算法必须有一个基本结束条件（直接解决最小规模的问题）</li><li>递归算法必须向基本结束条件演进（减小问题的规模）</li><li>递归算法必须调用自身（解决减小了规模的相同问题）</li></ul><p>这里以一个简单的例子解释，求列表所有元素的和。</p><blockquote><p>求列表和函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_list</span><span class="params">(li: list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> li:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(li) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li[<span class="number">0</span>] + sum_list(li[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> li[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(sum_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p><code>if not li:</code> 是对空列表进行特别处理，返回数值 0，和整个递归函数关系不大。</p><p>对于求和来说，如果只有一个数的和，那么没必要求和，直接返回；如果有两个数的和，那么将两个加起来，返回得数；如果有三个数的和，那么将第一个数加上后两个数的和，返回的数。从以上三种状态我们就能写出递归。</p><p><code>if len(li) &gt; 1:</code> 为 True 时，要是得问题规模减小，即当取列表第一个数与之后数的和求和；为 False 时，问题已经时最小规模，即列表中仅含有一个数。</p><p><img src="/images/img00011.png" alt=""></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>许多循环问题都可以使用递归解决，递归可应用的方面也有许多，这里就介绍几种。</p><h3 id="十进制转化任意进制"><a href="#十进制转化任意进制" class="headerlink" title="十进制转化任意进制"></a>十进制转化任意进制</h3><blockquote><p>转化函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(n: int, base: int)</span> -&gt; str:</span></span><br><span class="line">    NUM = <span class="string">'0123456789ABCDEF'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt; base:</span><br><span class="line">        <span class="keyword">return</span> NUM[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> convert(n // base, base) + NUM[n % base]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(convert(<span class="number">123</span>, <span class="number">16</span>))  <span class="comment"># 7B</span></span><br></pre></td></tr></table></figure><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔， 又称河内塔，问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>汉诺塔的规则:</p><ol><li>每次移动一个圆盘</li><li>大圆盘不能在小圆盘的上面</li></ol><p>我们分情况考虑:</p><ol><li><p>有 1 个圆盘时</p><ul><li><p>将圆盘直接从 Start 移到 End，Start —&gt; End</p><p><img src="/images/img00012.png" alt=""></p></li></ul></li><li><p>有 2 个圆盘时</p><ul><li><p>将小圆盘从 Start 移到 Middle，Start —&gt; Middle</p></li><li><p>将大圆盘从 Start 移到 End，Start —&gt; End</p></li><li><p>将小圆盘从 Middle 移到 End，Middle —&gt; End</p><p><img src="/images/img00013.png" alt=""></p></li></ul></li><li><p>有 3 个圆盘时</p><ul><li><p>将最大圆盘上面两个圆盘从 Start 移到 Middle，递归移动</p></li><li><p>将最大圆盘移到 End，Start —&gt; End</p></li><li><p>将两个圆盘从 Middle 移到 End，递归移动</p><p><img src="/images/img00014.png" alt=""></p></li></ul></li><li><p>有 n 个圆盘时</p><ul><li>将最大圆盘上面 n - 1 个圆盘从 Start 移到 Middle，递归移动</li><li>将最大圆盘移到 End，Start —&gt; End</li><li>将 n - 1 个圆盘从 Middle 移到 End，递归移动</li></ul></li></ol><p>根据上面的情况我们就能写出递归。</p><blockquote><p>移动汉诺塔</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(height, start, middle, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> height == <span class="number">1</span>:</span><br><span class="line">        print(start, <span class="string">'--&gt;'</span>, end)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        move(height - <span class="number">1</span>, start, end, middle)</span><br><span class="line"></span><br><span class="line">        print(start, <span class="string">'--&gt;'</span>, end)</span><br><span class="line"></span><br><span class="line">        move(height - <span class="number">1</span>, middle, start, end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    move(<span class="number">3</span>, <span class="string">'start '</span>, <span class="string">'middle'</span>, <span class="string">'end   '</span>)</span><br><span class="line"><span class="comment"># start  --&gt; end   </span></span><br><span class="line"><span class="comment"># start  --&gt; middle</span></span><br><span class="line"><span class="comment"># end    --&gt; middle</span></span><br><span class="line"><span class="comment"># start  --&gt; end   </span></span><br><span class="line"><span class="comment"># middle --&gt; start </span></span><br><span class="line"><span class="comment"># middle --&gt; end   </span></span><br><span class="line"><span class="comment"># start  --&gt; end</span></span><br></pre></td></tr></table></figure><p>而如果要显示每个柱上圆盘的情况写法就有些复杂了。</p><blockquote><p>汉诺塔圆盘情况</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pole</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, disks: list)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.disks = disks</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.disks.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, disk)</span>:</span></span><br><span class="line">        self.disks.append(disk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name + <span class="string">': '</span> + str(self.disks)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(a: Pole, b: Pole, c: Pole)</span>:</span></span><br><span class="line">    li = [str(a), str(b), str(c)]</span><br><span class="line">    li.sort()</span><br><span class="line">    print(li[<span class="number">2</span>], li[<span class="number">1</span>], li[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(height, start: Pole, middle: Pole, end: Pole)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> height == <span class="number">1</span>:</span><br><span class="line">        end.put(start.pick())</span><br><span class="line">        display(start, middle, end)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        move(height - <span class="number">1</span>, start, end, middle)</span><br><span class="line"></span><br><span class="line">        end.put(start.pick())</span><br><span class="line">        display(start, middle, end)</span><br><span class="line"></span><br><span class="line">        move(height - <span class="number">1</span>, middle, start, end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    tower = []</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> range(h):</span><br><span class="line">        tower.append(one + <span class="number">1</span>)</span><br><span class="line">    tower.reverse()</span><br><span class="line"></span><br><span class="line">    start_pole = Pole(<span class="string">'start'</span>, tower)</span><br><span class="line">    middle_pole = Pole(<span class="string">'middle'</span>, [])</span><br><span class="line">    end_pole = Pole(<span class="string">'end'</span>, [])</span><br><span class="line"></span><br><span class="line">    move(len(tower), start_pole, middle_pole, end_pole)</span><br><span class="line"><span class="comment"># start: [3, 2] middle: [] end: [1]</span></span><br><span class="line"><span class="comment"># start: [3] middle: [2] end: [1]</span></span><br><span class="line"><span class="comment"># start: [3] middle: [2, 1] end: []</span></span><br><span class="line"><span class="comment"># start: [] middle: [2, 1] end: [3]</span></span><br><span class="line"><span class="comment"># start: [1] middle: [2] end: [3]</span></span><br><span class="line"><span class="comment"># start: [1] middle: [] end: [3, 2]</span></span><br><span class="line"><span class="comment"># start: [] middle: [] end: [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h3 id="螺线"><a href="#螺线" class="headerlink" title="螺线"></a>螺线</h3><p>可以使用递归画一些自相似的图形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_spiral</span><span class="params">(t, length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">0</span>:</span><br><span class="line">        t.forward(length)</span><br><span class="line">        t.right(<span class="number">90</span>)</span><br><span class="line">        draw_spiral(t, length - <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = turtle.Turtle()</span><br><span class="line">    draw_spiral(t, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    turtle.done()</span><br></pre></td></tr></table></figure><p><img src="/images/img00015.png" alt=""></p><h3 id="找零"><a href="#找零" class="headerlink" title="找零"></a>找零</h3><p>零钱是货币体系中重要的一部分，这里我们以美分 ￠ 为例，硬币共有 1￠、5￠、10￠ 和 25￠。通常来说，如果要找一定价值的零钱，我们选择硬币数量最少进行找零，如找零 6￠，因该是 1 个 1￠ 和 1 个 5￠，而不是 6 个 1￠。</p><p>我们在这里使用贪心算法解决找零问题，需要说的是，贪心算法不一定能找到最优解，但是对于正常的货币体系来说，是没有问题的。我们这里默认每次找零，先按最大面值的找，逐步减小面值。</p><blockquote><p>找零</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(kinds: list, value: int)</span>:</span></span><br><span class="line">    min_num = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> kinds:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> one <span class="keyword">in</span> [coin <span class="keyword">for</span> coin <span class="keyword">in</span> kinds <span class="keyword">if</span> coin &lt; value]:</span><br><span class="line">            num = <span class="number">1</span> + change(kinds, value - one)</span><br><span class="line">            <span class="keyword">if</span> num &lt; min_num:</span><br><span class="line">                min_num = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(change([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>], <span class="number">63</span>))</span><br><span class="line">    print(<span class="string">'used: %3.2fs'</span> % (time.time() - start))</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># used: 25.50s</span></span><br></pre></td></tr></table></figure><p>在这里为什么需要那么多的时间，是因为一个面值的找零重复进行了许多次的计算，造成了不必要的浪费，我们现在改进一下。只需要记录一下已找到某个面值的最优解即可。</p><blockquote><p>改进找零</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(kinds: list, value: int, known: dict)</span>:</span></span><br><span class="line">    min_num = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> kinds:</span><br><span class="line">        known[value] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> value <span class="keyword">in</span> known:</span><br><span class="line">        <span class="keyword">return</span> known[value]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> one <span class="keyword">in</span> [coin <span class="keyword">for</span> coin <span class="keyword">in</span> kinds <span class="keyword">if</span> coin &lt; value]:</span><br><span class="line">            num = <span class="number">1</span> + change(kinds, value - one, known)</span><br><span class="line">            <span class="keyword">if</span> num &lt; min_num:</span><br><span class="line">                min_num = num</span><br><span class="line">                known[value] = min_num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(change([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>], <span class="number">63</span>, &#123;&#125;))</span><br><span class="line">    print(<span class="string">'used: %3.2fs'</span> % (time.time() - start))</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># used: 0.00s</span></span><br></pre></td></tr></table></figure><p>而记录是哪些面值的硬币就比较简单了，这里就不进行添加了。</p><p>解决找零问题可以使用动态规划，这样能适应各种各样的货币，而贪心算法是有缺陷的，如货币种类有 1￠、5￠、10￠  25￠ 和 21￠，找零 63，按照上面的贪心算法，得数为 6 （2 个 25￠、1 个 10￠，3 个 1￠），真正的得数应是 3（3 个 21￠）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性结构 Linear Structure</title>
      <link href="/2020/02/15/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-Linear-Structure/"/>
      <url>/2020/02/15/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-Linear-Structure/</url>
      
        <content type="html"><![CDATA[<p>线性结构是一种有序的数据项的集合，其中每个数据项都有唯一的前驱和后继，除第一项个没有前驱，最后一项没有后继，并且新的数据项添加到数据集中，只会添加到原有某个数据项之前或之后。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线性结构（Linear Structure）是一种有序的数据项的集合，其中每个数据项都有唯一的前驱和后继，除第一项个没有前驱，最后一项没有后继，并且新的数据项添加到数据集中，只会添加到原有某个数据项之前或之后。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>集合中必存在唯一的一个第一项</li><li>集合中必存在唯一的一个最后一项</li><li>除第一项之外，其他项均有唯一的前驱</li><li>除最后一项之外，其他项均有唯一的后继</li></ul><p>线性结构总有两端，前端 — 后端、左端 — 右端、顶端 — 底端。</p><p><img src="/images/img00001.png" alt=""></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据数据项的添加和移除的方式，即从前端添加和移除、从中间添加和移除、从后端添加和移除，可以分为</p><ul><li>栈 Stack</li><li>队列 Queue</li><li>双端队列 Deque</li><li>列表 List</li><li>串 String</li></ul><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>栈是一种有次序的数据项集合，在栈中，数据项的添加和移除仅发生在同一端，即栈顶，另一端固定不动，即栈底。</p><ul><li>栈顶 top: 数据项添加和移除的一端</li><li>栈底 bottom: 固定不动的一端</li></ul><p>在栈中，数据项的添加称为入栈，数据项的移除称为出栈。</p><ul><li>入栈 push: 又称为压栈，即添加数据项</li><li>出栈 pop: 又称为弹出，即移除数据项</li><li>查看 peek: 查看栈顶数据项，数据项不出栈</li></ul><p><img src="/images/img00002.png" alt=""></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p>First In Last Out.</p></blockquote><p>在栈中，第一个入栈的数据项总是最后一个出栈，并且一个数据项只有在其顶部数据项均被移除的情况下才能被移除，这种特性称为“先进后出”。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Python 实现简单的栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; object:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; object:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure><p>栈最基本的功能就是入栈 push 和出栈 pop。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>栈是具有顺序的数据结构，在许多方面都有应用，例如我们常常提到的栈溢出，它本质上就是一个栈，而栈并不是无限大从而有可能发生溢出。</p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>不管是在书写的文章中，还是代码中，都或多或少得存在一种成对的符号——括号（圆括号、方括号、花括号），括号总是成对出现，即有左括号，那么必须有右括号，否则就是不匹配，可能会造成语义上的混乱，例如初学 C 语言时，少写 <code>{</code> 或 <code>}</code> 造成编译错误。</p><p>括号具有顺序，并且可以嵌套，所以仅仅统计左括号和右括号的数量显然不正确，如 <code>)()()(</code>，这时候就可以使用栈进行匹配。</p><blockquote><p>圆括号匹配</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linear_structure.basic_stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parentheses_checker</span><span class="params">(string)</span> -&gt; bool:</span></span><br><span class="line">    s = Stack()</span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> symbol == <span class="string">'('</span>:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> symbol == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">if</span> s.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s.is_empty():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(parentheses_checker(<span class="string">'())'</span>))  <span class="comment"># False</span></span><br><span class="line">    print(parentheses_checker(<span class="string">'(123(abc)d)(ll)(1)'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><blockquote><p>括号匹配</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linear_structure.basic_stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brackets_checker</span><span class="params">(string)</span>:</span></span><br><span class="line">    start_symbols = <span class="string">'([&#123;'</span></span><br><span class="line">    end_symbols = <span class="string">')]&#125;'</span></span><br><span class="line"></span><br><span class="line">    s = Stack()</span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> start_symbols:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> end_symbols:</span><br><span class="line">            <span class="keyword">if</span> s.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> match(s.pop(), symbol):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s.is_empty():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    start_symbols = <span class="string">'([&#123;'</span></span><br><span class="line">    end_symbols = <span class="string">')]&#125;'</span></span><br><span class="line">    <span class="keyword">return</span> start_symbols.index(start) == end_symbols.index(end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(brackets_checker(<span class="string">'[&#123;[]&#125;][([])]'</span>))  <span class="comment"># True</span></span><br><span class="line">    print(brackets_checker(<span class="string">'&#123;[[]][([])]'</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>HTML、XML等结构化的文档也可以使用栈进行校验，在对成对出现的元素进行匹配时，栈是一个很好的工具。</p><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><p>栈的特点是“先进后出”，这正好符合反序的思想，可以使用栈来反转数据。</p><blockquote><p>反转函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linear_structure.basic_stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(string)</span> -&gt; str:</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    s = Stack()</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> string:</span><br><span class="line">        s.push(one)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> s.is_empty():</span><br><span class="line">        result += s.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(reverse(<span class="string">'12wqr3'</span>))  <span class="comment"># 3rqw21</span></span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>一个很常见的编程问题就是求一段数学表达式的值，通常数学表达式是一个字符串，在这里我们保证字符串数学表达式的正确性，并且只讨论非负整数和小数的加 +、减 -、乘 *、除 /。</p><p>对于一个数学表达式，如 10 + 3.14 * 2，一个字符串我们是无法直接进行处理的，首先要将字符串切片成一个个最小单位的元素，如 <code>10</code>、<code>+</code>、<code>3.14</code>、<code>+</code>、<code>2</code>，如果输入的时候每个元素之间存在空格，那么直接按空格切片处理，但通常不会有空格，所以我们先编写一个切片函数。</p><blockquote><p>切片函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(expression: str)</span> -&gt; list:</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(expression):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> expression[index].isdigit():</span><br><span class="line">            result.append(expression[index])</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> p &lt; len(expression) <span class="keyword">and</span> \</span><br><span class="line">                    (expression[p].isdigit() <span class="keyword">or</span> expression[p] == <span class="string">'.'</span>):</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            result.append(expression[index: p])</span><br><span class="line">            index = p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>虽然字符串经过切片，但直接处理非常复杂，不仅需要考虑运算符的优先级，还要考虑括号的影响。其实这是表达式本身缺陷导致的，我们通常使用的表达式，如 10 + 3.14 * 2，它是一个中缀表达式，即运算符在操作数中间，这易于人类读写，但对计算机极不友好，当然存在表达式的其他表示形式 —— 前缀表达式和后缀表达式。</p><p>表达式分为</p><ul><li><p>中缀表达式 infix expression</p><p>中缀表达式是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间，如 1 + 2，中缀表达式是人们常用的算术表示方法，并且相较于其他两种表示方法，在中缀表达式中括号是必须的，如 1 - (2 + 3)。</p></li><li><p>前缀表达式 prefix expression</p><p>前缀表达式又称“波兰式” Polish notation，由波兰数学家 Jan Lukasiewicz 发明，它是一种没有括号的算术表达式，与中缀表达式不同的是，它将运算符写在前面，操作数写在后面，如，- 1 + 2 3，等价于 1 - (2 + 3)。</p></li><li><p>后缀表达式 postfix expression</p><p>后缀表达式又称“逆波兰式” Reverse Polish notation，它将操作数写在前面，运算符写在后面，如 1 2 3 + -，等价于 1 - (2 + 3)。</p></li></ul><div class="table-container"><table><thead><tr><th>中缀表达式</th><th>前缀表达式</th><th>后缀表达式</th></tr></thead><tbody><tr><td>1 - (2 + 3)</td><td>- 1 + 2 3</td><td>1 2 3 + -</td></tr><tr><td>A / (B + C) * D</td><td>* / A +  B C D</td><td>A B C + / D *</td></tr></tbody></table></div><p>通常，我们将中缀表达式转换为逆波兰式，也就是后缀表达式进行计算，转换的一般算法是</p><p>准备一个空栈 operators_stack 和一个存放结果的列表 result，且中缀表达式已处理为每个元素都是一个最小单位。</p><ol><li>取元素</li><li>判断<ul><li>若元素是操作数，则直接将操作数放入列表 result 中</li><li>若元素是 ( ，则直接将 ( 压入栈 operators_stack 中</li><li>若元素是 ) ，则将距离栈顶 operators_stack top 最近的 ( 之间的运算符依次出栈放入列表 result 中，舍弃 (</li><li>若元素是操作符，则依次出栈所有优先级不低于当前运算符（栈顶运算符优先级高于或等于当前运算符的优先级）的运算符放入列表 result 中，特别的，遇到 ( 停止</li></ul></li><li>重复 1. 和 2. 直至处理完所有的元素</li><li>列表 result 为转化完的后缀表达式</li></ol><blockquote><p>转换为后缀表达式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> linear_structure.basic_stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_into_postfix_expression</span><span class="params">(split_expression: list)</span> -&gt; list:</span></span><br><span class="line">    result = []</span><br><span class="line">    operators_stack = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> split_expression:</span><br><span class="line">        <span class="keyword">if</span> is_number(one):</span><br><span class="line">            result.append(one)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> one == <span class="string">'('</span>:</span><br><span class="line">            operators_stack.push(one)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> one == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> operators_stack.is_empty():</span><br><span class="line">                operator = operators_stack.pop()</span><br><span class="line">                <span class="keyword">if</span> operator == <span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(operator)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> operators_stack.is_empty() <span class="keyword">and</span> \</span><br><span class="line">                    operators_stack.peek() != <span class="string">'('</span> <span class="keyword">and</span> \</span><br><span class="line">                    <span class="keyword">not</span> is_higher(one, operators_stack.peek()):</span><br><span class="line">                result.append(operators_stack.pop())</span><br><span class="line">            operators_stack.push(one)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_number</span><span class="params">(string: str)</span> -&gt; bool:</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'^[-+]?[-0-9]\d*\.\d*|[-+]?\.?[0-9]\d*$'</span>)</span><br><span class="line">    result = pattern.match(string)</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_higher</span><span class="params">(op1: str, op2: str)</span> -&gt; bool:</span></span><br><span class="line">    operators = &#123;</span><br><span class="line">        <span class="string">'+'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'-'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'*'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'/'</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operators[op1] &gt; operators[op2]</span><br></pre></td></tr></table></figure><p>转换为后缀表达式，我们就要开始计算了，后缀表达式的计算依然需要使用栈，计算方式为</p><ol><li>取元素</li><li>判断<ul><li>若元素是操作数，则直接将操作数压入栈中</li><li>若元素是运算符，则弹出栈中的两个操作数，根据运算符进行运算，得数压入栈中</li></ul></li><li>重复 1. 和 2. 直至处理完所有的元素</li><li>栈顶元素也是唯一元素即为结果</li></ol><blockquote><p>计算</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(expression: str)</span>:</span></span><br><span class="line">    split_expression = split(expression)</span><br><span class="line">    postfix_expression = transform_into_postfix_expression(split_expression)</span><br><span class="line"></span><br><span class="line">    numbers_stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> postfix_expression:</span><br><span class="line">        <span class="keyword">if</span> is_number(one):</span><br><span class="line">            numbers_stack.push(float(one))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numbers_stack.push(</span><br><span class="line">              do_math(one, numbers_stack.pop(), numbers_stack.pop())</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers_stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    exp = <span class="string">'1-((1*3.2+5)*4/6+2*43/(5-3+3*3)*534/534)'</span></span><br><span class="line">    </span><br><span class="line">    print(calculate(exp))  <span class="comment"># -12.284848484848485</span></span><br><span class="line">    print(eval(exp))  <span class="comment"># -12.284848484848485</span></span><br></pre></td></tr></table></figure><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>队列是一种有次序的数据集合，在队列中，数据项的添加总是发生在一段，即尾端，数据项的移除总是发生在另一端，即首端。</p><ul><li>尾端 rear: 数据项添加的一端</li><li>首端 front: 数据项移除的一端</li></ul><p>在队列中，数据项的添加称为入队，数据项的移除称为出队。</p><ul><li>入队 enqueue: 数据项的添加</li><li>出队 dequeue: 数据项的移除</li></ul><p><img src="/images/img00003.png" alt=""></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><blockquote><p>First In First Out.</p><p>First Come First Served.</p></blockquote><p>在队列中，第一个进入队的数据项总是第一个出队，并且一个数据项只有在其前部数据项均出队的情况下才能出队，这种特性称为“先进先出”或“先到先服务”。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>Python 实现简单的队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item: object)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span> -&gt; object:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure><p>队列最基本的功能就是入队 enqueue 和出队 dequeue。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>队列在日常生活中随处可见，如在餐馆排队等。</p><h4 id="模拟排队"><a href="#模拟排队" class="headerlink" title="模拟排队"></a>模拟排队</h4><p>计算机模拟是计算机应用一个重要的方面，毕竟有些情况在显示生活中不便于模拟，如花费较大的或者危险的等，使用计算机进行模拟就可以在一定程度上反应显示的相关情况。</p><p>首先我们先定义一个任务类，这个任务就像去冰激淋商店的一个顾客，显然他有到达商店的时间（用于统计等待时间）和购买冰激淋的数量，并且顾客到商店是一个随机事件。</p><blockquote><p>任务类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, created_time: int, num: int)</span>:</span></span><br><span class="line">        self.created_time = created_time</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_created_time</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.created_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_wait_time</span><span class="params">(self, current_time)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> current_time - self.created_time</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(current_time: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">1</span>, <span class="number">50</span>) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Task(current_time, random.randint(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>其次需要处理顾客订单的商店类</p><blockquote><p>商店类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, needed_seconds)</span>:</span></span><br><span class="line">        self.needed_seconds = needed_seconds</span><br><span class="line">        self.current_task = <span class="literal">None</span></span><br><span class="line">        self.remaining_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_task <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.remaining_time -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.remaining_time == <span class="number">0</span>:</span><br><span class="line">                self.current_task = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_busy</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.current_task <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, task: Task)</span>:</span></span><br><span class="line">        self.current_task = task</span><br><span class="line">        self.remaining_time = task.get_num() * self.needed_seconds</span><br></pre></td></tr></table></figure><p>现在我们就可以进行模拟了。</p><blockquote><p>模拟函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_queue</span><span class="params">(total_seconds: int, needed_seconds: int)</span>:</span></span><br><span class="line">    s = Shop(needed_seconds)</span><br><span class="line">    q = Queue()</span><br><span class="line">    wait_time = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> range(total_seconds):</span><br><span class="line">        task = Task.get_task(current)</span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            q.enqueue(task)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s.is_busy() <span class="keyword">and</span> <span class="keyword">not</span> q.is_empty():</span><br><span class="line">            next_task = q.dequeue()</span><br><span class="line">            wait_time.append(next_task.get_wait_time(current))</span><br><span class="line">            s.next(next_task)</span><br><span class="line"></span><br><span class="line">        s.tick()</span><br><span class="line"></span><br><span class="line">    average_wait_time = sum(wait_time) / len(wait_time)</span><br><span class="line">    print(<span class="string">'average wait time: %5.2f seconds, %2d tasks remaining.'</span></span><br><span class="line">          % (average_wait_time, q.size()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        simulate_queue(<span class="number">3600</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># average wait time: 27.15 seconds,  0 tasks remaining</span></span><br><span class="line"><span class="comment"># average wait time: 11.72 seconds,  0 tasks remaining</span></span><br><span class="line"><span class="comment"># average wait time: 14.14 seconds,  3 tasks remaining</span></span><br><span class="line"><span class="comment"># average wait time: 22.26 seconds,  1 tasks remaining</span></span><br><span class="line"><span class="comment"># average wait time: 45.51 seconds,  1 tasks remaining</span></span><br></pre></td></tr></table></figure><h4 id="约瑟夫圈"><a href="#约瑟夫圈" class="headerlink" title="约瑟夫圈"></a>约瑟夫圈</h4><p>约瑟夫圈也称为约瑟夫问题 Josephus problem，它的基本表述是有一定数量的人围成一个圆圈并轮流报数，当报到某个数字的人就出圈，报数重新开始，直到只剩下一个人。</p><blockquote><p>解决约瑟夫问题</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linear_structure.basic_queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_josephus_problem</span><span class="params">(total: int, num: int)</span> -&gt; int:</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> range(<span class="number">1</span>, total + <span class="number">1</span>):</span><br><span class="line">        q.enqueue(one)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> one <span class="keyword">in</span> range(num - <span class="number">1</span>):</span><br><span class="line">            q.enqueue(q.dequeue())</span><br><span class="line"></span><br><span class="line">        q.dequeue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q.dequeue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(solve_josephus_problem(<span class="number">10</span>, <span class="number">3</span>))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h2 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 Deque"></a>双端队列 Deque</h2><p>双端队列是一种有次序的数据项集合，在双端队列中，数据项的添加和移除发生在两端，和队列一样，我们将两端分为首端和尾端。</p><ul><li>尾端 rear: 数据项添加和移除的一端</li><li>首端 front: 数据项添加和移除的一端</li></ul><p>和队列一样，在双端队列中，数据项的添加称为入队，数据项的移除称为出队，只不过数据项的添加和移除区分从首端和从尾端。</p><ul><li>尾端入队 add rear: 向尾端添加数据项</li><li>尾端出队 remove rear: 从尾端移除数据项</li><li>首端入队 add front: 向首端添加数据项</li><li>首端出队 remove front: 从首端移除数据项</li></ul><p><img src="/images/img00004.png" alt=""></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><blockquote><p>It’s Up To You.</p></blockquote><p>双端队列既有队列的特性，也有栈的特性，使用者可以保持操作的一致性，使得双端队列表现成为队列或者栈。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>Python 实现简单的双端队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self, item: object)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_rear</span><span class="params">(self)</span> -&gt; object:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self, item: object)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_front</span><span class="params">(self)</span> -&gt; object:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>双端队列可以当作队列或者栈使用，所以使用队列或栈的方法，双端队列能够完成，这里介绍双端队列的特别应用。</p><h4 id="回文判定"><a href="#回文判定" class="headerlink" title="回文判定"></a>回文判定</h4><p>回文 Palindrome 是一种正序和倒序相同的一端文字，如 12321、321123。</p><blockquote><p>判断回文</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> linear_structure.basic_deque <span class="keyword">import</span> Deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome_check</span><span class="params">(string: str)</span> -&gt; bool:</span></span><br><span class="line">    d = Deque()</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> list(string):</span><br><span class="line">        d.add_rear(one)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> d.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> d.remove_rear() != d.remove_front():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(palindrome_check(<span class="string">'1212'</span>))  <span class="comment"># False</span></span><br><span class="line">    print(palindrome_check(<span class="string">'121'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h2><p>列表是一种有次序的数据项集合，根据数据项是否有序，列表分为</p><ul><li><p>无序表 Unordered List</p><p>在无序表中，数据项的添加和移除可以发生在任意位置</p></li><li><p>有序表 Ordered List</p><p>在有序表中，数据项的添加和移除发生在某一固定位置</p></li></ul><p>根据数据项的存储形式，列表</p><ul><li><p>顺序表 Contiguous List</p><p>在顺序表中，数据项在内存空间是顺序存储的</p></li><li><p>链表 Linked List</p><p>在链表中，数据项在内存空间中是链式存储的，是没有规律的，一个数据项内存储着下一个数据项的内存地址</p></li></ul><h3 id="无序表-Unordered-List"><a href="#无序表-Unordered-List" class="headerlink" title="无序表 Unordered List"></a>无序表 Unordered List</h3><p>无序表与有序表是相对的，无序表是数据项的排列不具有顺序性。并且无序表是可以经过排序变为有序表，常用的排序算法有: 冒泡排序、插入排序、桶排序、计数排序、合并排序、选择排序、快速排序、堆排序等。</p><p>在无序表中，数据项的添加和移除可以发生在任意位置。</p><ul><li>添加到表末尾 append: 添加数据项到表末尾</li><li>添加到指定位置 insert: 添加数据项到指定位置</li><li>移除 pop: 移除指定位置的数据项</li><li>查找 search: 查找数据项在有序表中是否存在，必须遍历整个表</li></ul><p><img src="/images/img00005.png" alt=""></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>Python 实现简单的无序表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, index, item)</span>:</span></span><br><span class="line">        self.items.insert(index, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        self.items.pop(*args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> one <span class="keyword">in</span> self.items:</span><br><span class="line">            <span class="keyword">if</span> one == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="有序表-Ordered-List"><a href="#有序表-Ordered-List" class="headerlink" title="有序表 Ordered List"></a>有序表 Ordered List</h3><p>有序表中所有数据项以递增或递减方式排列，并规定有序表中可存在元素值相同的元素。</p><p>在有序表中，数据项的添加和移除发生在某一固定位置。</p><ul><li>添加 add: 添加数据项，数据项会根据顺序性添加到某一特定位置</li><li>移除 remove: 移除数据项，数据项会被移除，但并不会破坏移除后数据项的有序性</li><li>查找 search: 查找数据项在有序表中是否存在，按照顺序查找，可以使用二分法</li></ul><p><img src="/images/img00006.png" alt=""></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>首先要放入有序表的数据项必须是可比的，否则无意义，在这里我们只需要保证数据项可以使用 <code>&gt;</code> 进行比较，在 Python 中，只需要重载 <code>__gt__()</code> 即可。</p><p>Python 实现简单的有序表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(self.items):</span><br><span class="line">            <span class="keyword">if</span> self.items[index] &gt; item:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        self.items.insert(index, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(self.items) <span class="keyword">and</span> <span class="keyword">not</span> self.items[index] &gt; item:</span><br><span class="line">            <span class="keyword">if</span> self.items[index] == item:</span><br><span class="line">                self.items.pop(index)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(self.items) <span class="keyword">and</span> <span class="keyword">not</span> self.items[index] &gt; item:</span><br><span class="line">            <span class="keyword">if</span> self.items[index] == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="顺序表-Contiguous-List"><a href="#顺序表-Contiguous-List" class="headerlink" title="顺序表 Contiguous List"></a>顺序表 Contiguous List</h3><p>顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。</p><p><img src="/images/img00007.png" alt=""></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>顺序表和 Python 中的列表 List 一致并且和其他编程语言的数组本质相同，在这里就不重复实现了。</p><h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h3><p>链表实际上是线性表的链式存储结构，与顺序表不同的是，它是用一组任意的内存地址来存储线性表中的数据，存储地址不一定是连续的。链表的每个元素称为一个节点，每个节点都可以存储在内存中的不同的位置，并且每个节点中存储着数据项本身和一个指向下一个节点的指针（或者节点的引用）。</p><p><img src="/images/img00008.png" alt=""></p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>我们在这里讨论的链表一般指单向链表。节点是链表的核心，它存储着数据项本身和下一个节点，所以我们首先实现节点类。</p><p>节点类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_next</span><span class="params">(self, next)</span>:</span></span><br><span class="line">        self.next = next</span><br></pre></td></tr></table></figure><p>链表类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        n = Node(data)</span><br><span class="line">        n.set_next(self.head)</span><br><span class="line">        self.head = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = self.head</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n.get_next()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        n = self.head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> n.get_data() == data:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            n = n.get_next()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.head.get_data() == data:</span><br><span class="line">                self.head = self.head.get_next()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                previous = self.head</span><br><span class="line">                n = previous.get_next()</span><br><span class="line">                <span class="keyword">while</span> n <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> n.get_data() == data:</span><br><span class="line">                        previous.set_next(n.get_next())</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    previous = n</span><br><span class="line">                    n = previous.get_next()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII 码</title>
      <link href="/2020/02/04/ASCII-%E7%A0%81/"/>
      <url>/2020/02/04/ASCII-%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>ASCII (American Standard Code for Information Interchange 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。</p><a id="more"></a><div class="table-container"><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>闭单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号/破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>/</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>=</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>`</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>\</td><td></td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> ascii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法和编辑器 Typora</title>
      <link href="/2020/02/03/Markdown-%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8-Typora/"/>
      <url>/2020/02/03/Markdown-%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8-Typora/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级的标记语言，相比较复杂的 HTML 标记语言，Markdown 更为简洁，常用的标记符号不过十余种，学习成本比较低，深受程序员等文稿编写者喜爱。并且 Markdown 也十分强大，不管是流程图等图表，还是复杂的数学公式，Markdown 都能处理地游刃有余。强大的语言也必有强大的编辑器，Typora 就是一个强大的 Markdown 语言实时预览编辑器。</p><a id="more"></a><h2 id="Markdown-简介"><a href="#Markdown-简介" class="headerlink" title="Markdown 简介"></a>Markdown 简介</h2><blockquote><p>Markdown is intended to be as easy-to-read and easy-to-write as is feasible.</p></blockquote><p>Markdown 是一种轻量级的标记语言，它用特定的符号和符号组合描述文字的特征，从而使文字能够表现出不同的视觉效果，Markdown 不同于 Microsoft Word 需要大量的文字排版和字体的选择，它秉持着简易的思想，在编写的过程中，作者不需要处理复杂的排版错误以及考虑选择什么样的字体，仅仅是使用预定的标记格式书写纯文本的文章，并且作者的手可以完全不离开键盘，专心码字。</p><p>虽然 Markdown 十分简易，但它也非常强大。Markdown 不仅有基本的文章格式，如标题、文字删除线等，也能够胜任轻量级图标的绘制和数学公式的表达。</p><p><img src="/images/markdown_introduction.png" alt=""></p><p>Markdown 融入了类似前后端分离的思想，这里所说的后端也就是作者，作者只需要按照规定的格式书写文章，然后交给前端渲染器进行渲染，从而得到一篇完美的文章。Markdown 可以导出不同的格式，如 PDF、HTML、Word等，当然这需要编辑器的支持。</p><h2 id="Markdown-编辑器"><a href="#Markdown-编辑器" class="headerlink" title="Markdown 编辑器"></a>Markdown 编辑器</h2><p>Markdown 有各种各样的编辑器，如 MacDown、MarkdownPad、VS Code等，它们能够渲染出不同的文章视觉，但大体上是一致的。</p><p>这里介绍一个强大的 Markdown 实时预览编辑器 Typora。</p><p><img src="/images/typora_introduction.png" alt=""></p><p>Typora 官网：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io</a></p><p>Typora 是一款免费的多平台的（macOS、Windows、Linux）的极简的 Markdown 编辑器。Typora 允许你直接书写 Markdown 标记语言，并实时渲染现实在屏幕上，它也允许你像使用富文本编辑器那样，先书写文字，然后通过快捷键或者选择特定的格式，来生成想要的文章视觉。</p><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><p>在不同的 Markdown 编辑器中，语法略有不同，但大致一样，它们都遵循一套基本的 Markdown 标记语言规范，可以寻找一个适合自己的风格。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题是最常用的格式，在每篇文章中都比不可少。在 Markdown 中定义标题，只需要在文字前添加 <code>#</code> 后跟一个空格，<code>#</code> 的个数代表标题的级数，分为一至六级标题，也可以使用 <code>#</code> 包含文字。并且目录是根据标题生成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line"></span><br><span class="line"># 一级标题</span><br></pre></td></tr></table></figure><p><img src="/images/title_level.png" alt=""></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表分为有序列表和无序列表。定义无序列表，在文字前添加 <code>-</code> 或 <code>*</code> 或 <code>+</code> 后跟一个空格。定义有序列表，在文字前添加 <code>1.</code> <code>2.</code> <code>3.</code> 等符号后跟一个空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- c</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line">1. a</span><br><span class="line">2. b</span><br><span class="line">3. c</span><br></pre></td></tr></table></figure><p><img src="/images/list.png" alt=""></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格的定义比较麻烦，但也比较形象，使用 <code>|</code> 和 <code>-</code> 表示表格的边界，定义一个表格的形式如下，第一行为列的标题，第二行表示表格的对齐方式，<code>-</code> 为默认对齐方式， <code>:-</code> 为左对齐，<code>-:</code> 为右对齐，<code>:-:</code> 为居中，从第三行起为内容。在 Markdown 中不允许合并单元格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Name  | Gender | Age  |</span><br><span class="line">| ----- |:------ |:----:|</span><br><span class="line">| Leo   | Male   | 20   |</span><br><span class="line">| Fiona | Female | 18   |</span><br></pre></td></tr></table></figure><p><img src="/images/table.png" alt=""></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>定义斜体，使用 <code>*</code> 或 <code>_</code> 包含一段文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*这是一段斜体文字*</span><br></pre></td></tr></table></figure><p><img src="/images/italic.png" alt=""></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>定义粗体，使用 <code>**</code> 或 <code>__</code> 包含一段文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**这是一段粗体文字**</span><br></pre></td></tr></table></figure><p><img src="/images/bold.png" alt=""></p><h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h3><p>定义粗斜体，使用 <code>***</code> 或 <code>___</code>包含一段文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***这是一段粗斜体文字***</span><br></pre></td></tr></table></figure><p><img src="/images/italic_bold.png" alt=""></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>定义删除线，使用 <code>~~</code> 包含一段文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是一段删除文字~~</span><br></pre></td></tr></table></figure><p><img src="/images/deleted.png" alt=""></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>定义下划线，使用 <code>&lt;u&gt;</code> 和 <code>&lt;/u&gt;</code> 包含一段文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;这是一段下划文字&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/underline.png" alt=""></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>定义分割线，在一行使用 <code>***</code> 或者 <code>---</code>，或者三个以上的 <code>*</code>或 <code>-</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p><img src="/images/line.png" alt=""></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>定义引用，文字之前添加 <code>&gt;</code> 后跟一个空格，也可以多层引用嵌套，在前面使用多个 <code>&gt;</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用的文字</span><br><span class="line">&gt;&gt; 引用文字 引用文字</span><br></pre></td></tr></table></figure><p><img src="/images/quote.png" alt=""></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>定义链接，使用 <code>[]()</code>，<code>[]</code> 中添加链接的名字，<code>()</code> 中添加链接的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Baidu](https:&#x2F;&#x2F;www.baidu.com)</span><br></pre></td></tr></table></figure><p><img src="/images/link.png" alt=""></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>定义图片，使用 <code>![]()</code>，<code>[]</code> 中添加图片的名字，<code>()</code> 中添加图片的地址，地址可以是图片的相对或绝对地址，也可以是网络链接，通过生成图片的 base 64 也能添加图片，但是并不推荐使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![image](&#x2F;images&#x2F;img.png)</span><br><span class="line">![image](https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;baidu_resultlogo@2.png)</span><br></pre></td></tr></table></figure><p><img src="/images/baidu.png" alt=""></p><h3 id="行间代码"><a href="#行间代码" class="headerlink" title="行间代码"></a>行间代码</h3><p>定义行间代码，使用 <code>` </code> 包含代码，行间代码会给文字添加底色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;这是行间代码&#96;</span><br></pre></td></tr></table></figure><p><img src="/images/inline_code.png" alt=""></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>定义代码块，使用 <code>``` </code> 包含代码，在前 <code>``` </code> 后可跟代码类型，便于渲染器添加代码高亮。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`python</span></span><br><span class="line"><span class="string"># python</span></span><br><span class="line"><span class="string">print('Hello World')</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure><p><img src="/images/block_code.png" alt=""></p><h3 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h3><p>定义代办事项，使用 <code>- [x]</code> 后跟文字，<code>[]</code> 中必须是空格或者 x。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [x] 已办事项</span><br><span class="line">- [ ] 未办事项</span><br></pre></td></tr></table></figure><p><img src="/images/thing.png" alt=""></p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>定义上标，使用 <code>&lt;sup&gt;</code> 和 <code>&lt;/sup&gt;</code> 包含文字。定义下标，使用 <code>&lt;sub&gt;</code> 和 <code>&lt;/sub&gt;</code> 包含文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通文字&lt;sup&gt;上标&lt;&#x2F;sup&gt;</span><br><span class="line">普通文字&lt;sub&gt;下标&lt;&#x2F;sub&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/sup_sub.png" alt=""></p><h2 id="Markdown-数学公式"><a href="#Markdown-数学公式" class="headerlink" title="Markdown 数学公式"></a>Markdown 数学公式</h2><p>绝大部份 Markdown 都内嵌 LaTeX 数学公式模块，所以 LaTeX 数学公式的语法就是 Markdown 数学公式的语法。</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>公式分为行内公式和块公式。定义行内公式，使用 <code>$</code> 包含公式。定义块公式，使用 <code>$$</code> 包含公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行内公式</span><br><span class="line">$ c &#x3D; \sqrt&#123;a^2 + b^2&#125; $</span><br><span class="line"></span><br><span class="line">块公式</span><br><span class="line">$$</span><br><span class="line">c &#x3D; \sqrt&#123;a^2 + b^2&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><blockquote><p>行内公式<br>$ c = \sqrt{a^2 + b^2} $</p><p>块公式</p><script type="math/tex; mode=display">c = \sqrt{a^2 + b^2}</script></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>因为 LaTeX 数学公式需要许多的特殊字符代表特定的意思，从而使得这些特殊字符只能通过转义的方式显示，当然也有许多可转义的文字，如 \sqrt（开平方）等。如果需要转义某个特殊文字，就在文字前面添加 <code>\</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">r &#x3D; \sqrt&#123;\sqrt&#123;\sqrt&#123;a&#125;&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><blockquote><script type="math/tex; mode=display">r = \sqrt{\sqrt{\sqrt{a}}}</script></blockquote><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>因为在古希腊，出现过许多伟大的数学家，他们发明了很多符号，于是很多数学符号都是希腊字母，一直沿用至今。随着数学的发展许多希腊字母也代表了不同的意思，在公式中占据重要的一部分。</p><div class="table-container"><table><thead><tr><th>字母</th><th>LaTeX 格式</th><th>字母</th><th>LaTeX 格式</th></tr></thead><tbody><tr><td>$ A $ $ \alpha $</td><td><code>$A$</code> <code>$\alpha$</code></td><td>$ N $ $ \nu $</td><td><code>$N$</code> <code>$\nu$</code></td></tr><tr><td>$ B $ $ \beta $</td><td><code>$B$</code> <code>$\beta$</code></td><td>$ \Xi $ $ \xi $</td><td><code>$\Xi$</code> <code>$\xi$</code></td></tr><tr><td>$ \Gamma $ $ \gamma $</td><td><code>$\Gamma$</code> <code>$\gamma$</code></td><td>$ O $ $ o $</td><td><code>$O$</code> <code>$o$</code></td></tr><tr><td>$ \Delta $ $ \delta $</td><td><code>$\Delta$</code> <code>$\delta$</code></td><td>$ \Pi $ $ \pi $</td><td><code>$\Pi$</code> <code>$\pi$</code></td></tr><tr><td>$ E $ $ \epsilon $</td><td><code>$E$</code> <code>$\epsilon$</code></td><td>$ P $ $ \rho $</td><td><code>$P$</code> <code>$\rho$</code></td></tr><tr><td>$ Z $ $ \zeta $</td><td><code>$Z$</code> <code>$\zeta$</code></td><td>$ \Sigma $ $ \sigma $</td><td><code>$\Sigma$</code> <code>$\sigma$</code></td></tr><tr><td>$ H $ $ \eta $</td><td><code>$H$</code> <code>$\eta$</code></td><td>$ T $ $ \tau $</td><td><code>$T$</code> <code>$\tau$</code></td></tr><tr><td>$ \Theta $ $ \theta $</td><td><code>$\Theta$</code> <code>$\theta$</code></td><td>$ \Upsilon $ $ \upsilon $</td><td><code>$\Upsilon$</code> <code>$\upsilon$</code></td></tr><tr><td>$ Ι $ $ \iota$</td><td><code>$Ι$</code> <code>$\iota$</code></td><td>$ \Phi $ $ \phi $</td><td><code>$\Phi$</code> <code>$\phi$</code></td></tr><tr><td>$ K $ $ \kappa $</td><td><code>$K$</code> <code>$\kappa$</code></td><td>$ X $ $ \chi $</td><td><code>$X$</code> <code>$\chi$</code></td></tr><tr><td>$ \Lambda $ $ \lambda $</td><td><code>$\Lambda$</code> <code>$\lambda$</code></td><td>$ \Psi $ $ \psi $</td><td><code>$\Psi$</code> <code>$\psi$</code></td></tr><tr><td>$ M $ $ \mu $</td><td><code>$M$</code> <code>$\mu$</code></td><td>$ \Omega $ $ \omega $</td><td><code>$\Omega$</code> <code>$\omega$</code></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>希腊字母变量 字母</th><th>LaTeX 格式</th></tr></thead><tbody><tr><td>$ \varepsilon $    $ E $ $ \epsilon $</td><td><code>$\varepsilon$</code> <code>$E$</code> <code>$\epsilon$</code></td></tr><tr><td>$ \vartheta $    $ \Theta $ $ \theta $</td><td><code>$\vartheta$</code> <code>$\Theta$</code> <code>$\theta$</code></td></tr><tr><td>$ \varkappa $    $ K $ $ \kappa $</td><td><code>$\varkappa$</code> <code>$K$</code> <code>$\kappa$</code></td></tr><tr><td>$ \varpi $    $ \Pi $ $ \pi $</td><td><code>$\varpi$</code> <code>$\Pi$</code> <code>$\pi$</code></td></tr><tr><td>$ \varrho  $    $ P $ $ \rho $</td><td><code>$\varrho$</code> <code>$P$</code> <code>$\rho$</code></td></tr><tr><td>$ \varsigma $    $ \Sigma $ $ \sigma $</td><td><code>$\varsigma$</code> <code>$\Sigma$</code> <code>$\sigma$</code></td></tr><tr><td>$ \varphi $    $ \Phi $ $ \phi $</td><td><code>$\varphi$</code> <code>$\Phi$</code> <code>$\phi$</code></td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">质量</span><br><span class="line">$$</span><br><span class="line">m &#x3D; \rho V</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><blockquote><p>质量</p><script type="math/tex; mode=display">m = \rho V</script></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
